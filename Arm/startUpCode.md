# Startup Code (Lec 12)

`startup` is the first code that runs after `Reset`, followed by `main()`.

![alt text](image-7.png)

feature entry point, driver entry point

## Responsibilities

1. Initialize `SP` (must be initialized before any code runs)
   - after soft reset, `SP` value is zero (will cause overflow)
   - after hard reset, `SP` value is grabage

2. copy `.data` from ROM to RAM

3. initialize `.bss` by zeroes

4. initialize other HW (ex: in STM, startup code inits `PLL_Clk`)

5. allocate vector table

6. jump to `main()`

startup code is generic regarding `SP`, `.data` and `.bss`.

startup code is a code the requires stack to execute, so how does it init stack? startup code would be written in assembly and not generated by compiler so no stacking/unstacking instructions are generated. `Arm` solution was to init `SP` by HW, which allowed for startup code implementation in C.

## initialization of `.data` and `.bss`

![alt text](image-8.png)

using start and end pointers for memory sections that are defined during linking, startup code is written to initialize the required sections.

```c
void init_bss(uint32_t* start, uint32_t* end){
    uint32_t* current = start;
    while(current < end){   //not (<=) because last location is not .bss
        *current = 0;
        current++;
    }
}

void init_data(uint32_t* src_start,uint32_t* dst_start, uint32_t* dst_end){
    /* src (ROM), dst (RAM) */
    /*
    uint32_t* current = dst_start;
    while(current < dst_end){
        *current = *src_start;
    }
    */
    uint32_t* current_dst = dst_start;
    uint32_t* current_src = src_start;
    while(current_dst < dst_end){
        *current_dst = *current_src;
        current_dst++;
        current_src++;
    }
}
```

initializing `.bss` by zeroes is a c-standard. Erased memory contains values as `0xFF` which would cause different sized variables to contain different values (ex: 1-byte variable is init by 255 while 2-byte variable is init by 65k).

## Reset Sequence

after `Reset`, `PC` takes the value placed at first location in vector table (first location in flash) which should be startup code address. so the `Reset sequence` consists of `jump` to first location in VT, `fetch` value and `jump` to that value by placing it in `PC`.

```c
/* linker script */
memory{
    ROM: origin = 0x0800 0000
}
sections{
    .reset_vector{
        *(.resetVector)
    } > ROM     //first location in ROM
}

/* file.c */
__attribute__((section("reset_vector").used));
const uint32_t startup_add = (uint32_t)startupFunction;
```

`Reset Vector` is a list of pointers (4-bytes each).

`Arm` changed the sequence to include `SP` initialization by HW so that it becomes `jump` to first location in Flash, `fetch` value to init `SP`, increment `PC` to second location, `jump` to that location (startup code). This sequence allowed for writing startup code in C.

in Short, HW performs the following:

```c
PC = reset_vector
SP = *PC
PC++
PC = *PC
```

## Notes

processor can't detect stack overflow (no SP_end register), so detecting can be done through SW by writing a special value at stack end and check it, once changed it would mean that it is overwritten and stack overflow occured.

place last location in RAM to be first thing in `.isr_vector` section (`SP` init value) and startup code address in second location.
